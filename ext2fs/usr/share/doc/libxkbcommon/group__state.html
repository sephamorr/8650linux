<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>libxkbcommon: Keyboard State</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libxkbcommon
   &#160;<span id="projectnumber">0.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__state.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Keyboard State</div>  </div>
</div><!--header-->
<div class="contents">

<p>Creating, destroying and manipulating keyboard state objects.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga631f03db07f30774659ab3f787b152e7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga631f03db07f30774659ab3f787b152e7">xkb_key_direction</a> { <br/>
&#160;&#160;<a class="el" href="group__state.html#gga631f03db07f30774659ab3f787b152e7aa685cb474cd090014d1049f74c3e3ec5">XKB_KEY_UP</a>, 
<br/>
&#160;&#160;<a class="el" href="group__state.html#gga631f03db07f30774659ab3f787b152e7a10b02b45f1fceae1b43bc69162f84678">XKB_KEY_DOWN</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga631f03db07f30774659ab3f787b152e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the direction of the key (press / release).  <a href="group__state.html#ga631f03db07f30774659ab3f787b152e7">More...</a><br/></td></tr>
<tr class="separator:ga631f03db07f30774659ab3f787b152e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04e8eac0666cc64dee6f0d5a7a773a03"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> { <br/>
&#160;&#160;<a class="el" href="group__state.html#gga04e8eac0666cc64dee6f0d5a7a773a03a82fc290363aaa579fa4957c7a72b8ce6">XKB_STATE_MODS_DEPRESSED</a> = (1 &lt;&lt; 0), 
<br/>
&#160;&#160;<a class="el" href="group__state.html#gga04e8eac0666cc64dee6f0d5a7a773a03af95b6c2b4979c32588abe8a960351434">XKB_STATE_MODS_LATCHED</a> = (1 &lt;&lt; 1), 
<br/>
&#160;&#160;<a class="el" href="group__state.html#gga04e8eac0666cc64dee6f0d5a7a773a03a95d6c496c78b6da162f7c78fbfc22bbc">XKB_STATE_MODS_LOCKED</a> = (1 &lt;&lt; 2), 
<br/>
&#160;&#160;<a class="el" href="group__state.html#gga04e8eac0666cc64dee6f0d5a7a773a03a2357b9f2490e89ab2d549695ea49de4f">XKB_STATE_MODS_EFFECTIVE</a> = (1 &lt;&lt; 3), 
<br/>
&#160;&#160;<a class="el" href="group__state.html#gga04e8eac0666cc64dee6f0d5a7a773a03ae2030e8ff7db5ee988920633e2b08e88">XKB_STATE_LAYOUT_DEPRESSED</a> = (1 &lt;&lt; 4), 
<br/>
&#160;&#160;<a class="el" href="group__state.html#gga04e8eac0666cc64dee6f0d5a7a773a03aaed45ef0bd8de351e096178c9b559345">XKB_STATE_LAYOUT_LATCHED</a> = (1 &lt;&lt; 5), 
<br/>
&#160;&#160;<a class="el" href="group__state.html#gga04e8eac0666cc64dee6f0d5a7a773a03a8b3f6503e09ad7a43a3be092cc7cfaca">XKB_STATE_LAYOUT_LOCKED</a> = (1 &lt;&lt; 6), 
<br/>
&#160;&#160;<a class="el" href="group__state.html#gga04e8eac0666cc64dee6f0d5a7a773a03a751a3a712f1a25225e13114266b29726">XKB_STATE_LAYOUT_EFFECTIVE</a> = (1 &lt;&lt; 7), 
<br/>
&#160;&#160;<a class="el" href="group__state.html#gga04e8eac0666cc64dee6f0d5a7a773a03a9d22ee4abdad31a3e24afdede62c3c6d">XKB_STATE_LEDS</a> = (1 &lt;&lt; 8)
<br/>
 }</td></tr>
<tr class="memdesc:ga04e8eac0666cc64dee6f0d5a7a773a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifier and layout types for state objects.  <a href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">More...</a><br/></td></tr>
<tr class="separator:ga04e8eac0666cc64dee6f0d5a7a773a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf79b475eb908309ae1aa0e231b2c9aa8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gaf79b475eb908309ae1aa0e231b2c9aa8">xkb_state_match</a> { <br/>
&#160;&#160;<a class="el" href="group__state.html#ggaf79b475eb908309ae1aa0e231b2c9aa8acc8bf019ef4abad1eff3762ab67fd1cf">XKB_STATE_MATCH_ANY</a> = (1 &lt;&lt; 0), 
<br/>
&#160;&#160;<a class="el" href="group__state.html#ggaf79b475eb908309ae1aa0e231b2c9aa8a22afd2884474ad692b580a8b91413b5f">XKB_STATE_MATCH_ALL</a> = (1 &lt;&lt; 1), 
<br/>
&#160;&#160;<a class="el" href="group__state.html#ggaf79b475eb908309ae1aa0e231b2c9aa8a4ae1c11ddb747718871afb24adbfb0d6">XKB_STATE_MATCH_NON_EXCLUSIVE</a> = (1 &lt;&lt; 16)
<br/>
 }</td></tr>
<tr class="memdesc:gaf79b475eb908309ae1aa0e231b2c9aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match flags for xkb_state_mod_indices_are_active and xkb_state_mod_names_are_active, specifying how the conditions for a successful match.  <a href="group__state.html#gaf79b475eb908309ae1aa0e231b2c9aa8">More...</a><br/></td></tr>
<tr class="separator:gaf79b475eb908309ae1aa0e231b2c9aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga281f0dc1cab624ab11e7c4d318d9d4ac"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga281f0dc1cab624ab11e7c4d318d9d4ac">xkb_state::xkb_state_new</a> (struct <a class="el" href="structxkb__keymap.html">xkb_keymap</a> *keymap)</td></tr>
<tr class="memdesc:ga281f0dc1cab624ab11e7c4d318d9d4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new keyboard state object for a keymap.  <a href="#ga281f0dc1cab624ab11e7c4d318d9d4ac">More...</a><br/></td></tr>
<tr class="separator:ga281f0dc1cab624ab11e7c4d318d9d4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga331c9404262721da3f657eb9300c0eef"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga331c9404262721da3f657eb9300c0eef">xkb_state::xkb_state_ref</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state)</td></tr>
<tr class="memdesc:ga331c9404262721da3f657eb9300c0eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a new reference on a keyboard state object.  <a href="#ga331c9404262721da3f657eb9300c0eef">More...</a><br/></td></tr>
<tr class="separator:ga331c9404262721da3f657eb9300c0eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf5a9ee65857c4bdb7fbb5fbaa2dc115"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gacf5a9ee65857c4bdb7fbb5fbaa2dc115">xkb_state::xkb_state_unref</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state)</td></tr>
<tr class="memdesc:gacf5a9ee65857c4bdb7fbb5fbaa2dc115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a reference on a keybaord state object, and possibly free it.  <a href="#gacf5a9ee65857c4bdb7fbb5fbaa2dc115">More...</a><br/></td></tr>
<tr class="separator:gacf5a9ee65857c4bdb7fbb5fbaa2dc115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cad922d12dcfe040db29db77c88b876"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structxkb__keymap.html">xkb_keymap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga7cad922d12dcfe040db29db77c88b876">xkb_state::xkb_state_get_keymap</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state)</td></tr>
<tr class="memdesc:ga7cad922d12dcfe040db29db77c88b876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the keymap from which a keyboard state object was created.  <a href="#ga7cad922d12dcfe040db29db77c88b876">More...</a><br/></td></tr>
<tr class="separator:ga7cad922d12dcfe040db29db77c88b876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac554aa20743a621692c1a744a05e06ce"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gac554aa20743a621692c1a744a05e06ce">xkb_state::xkb_state_update_key</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, enum <a class="el" href="group__state.html#ga631f03db07f30774659ab3f787b152e7">xkb_key_direction</a> direction)</td></tr>
<tr class="memdesc:gac554aa20743a621692c1a744a05e06ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the keyboard state to reflect a given key being pressed or released.  <a href="#gac554aa20743a621692c1a744a05e06ce">More...</a><br/></td></tr>
<tr class="separator:gac554aa20743a621692c1a744a05e06ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47311e7268935dd2fe3e6ef057a82cb0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga47311e7268935dd2fe3e6ef057a82cb0">xkb_state::xkb_state_key_get_syms</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, const <a class="el" href="xkbcommon_8h.html#a79e604a22703391bdfe212cfc10ea007">xkb_keysym_t</a> **syms_out)</td></tr>
<tr class="memdesc:ga47311e7268935dd2fe3e6ef057a82cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the keysyms obtained from pressing a particular key in a given keyboard state.  <a href="#ga47311e7268935dd2fe3e6ef057a82cb0">More...</a><br/></td></tr>
<tr class="separator:ga47311e7268935dd2fe3e6ef057a82cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae56031a8c1d48e7802da32f5f39f5738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xkbcommon_8h.html#a79e604a22703391bdfe212cfc10ea007">xkb_keysym_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gae56031a8c1d48e7802da32f5f39f5738">xkb_state::xkb_state_key_get_one_sym</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key)</td></tr>
<tr class="memdesc:gae56031a8c1d48e7802da32f5f39f5738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the single keysym obtained from pressing a particular key in a given keyboard state.  <a href="#gae56031a8c1d48e7802da32f5f39f5738">More...</a><br/></td></tr>
<tr class="separator:gae56031a8c1d48e7802da32f5f39f5738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac59ad6a608fb36055ecaf8d09449174f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gac59ad6a608fb36055ecaf8d09449174f">xkb_state::xkb_state_key_get_layout</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key)</td></tr>
<tr class="memdesc:gac59ad6a608fb36055ecaf8d09449174f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the effective layout index for a key in a given keyboard state.  <a href="#gac59ad6a608fb36055ecaf8d09449174f">More...</a><br/></td></tr>
<tr class="separator:gac59ad6a608fb36055ecaf8d09449174f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ec69be58f357c924b7c99c075631d74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xkbcommon_8h.html#a7eb38bea2a311b6ff033816278d5bbea">xkb_level_index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga6ec69be58f357c924b7c99c075631d74">xkb_state::xkb_state_key_get_level</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, <a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> layout)</td></tr>
<tr class="memdesc:ga6ec69be58f357c924b7c99c075631d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the effective shift level for a key in a given keyboard state and layout.  <a href="#ga6ec69be58f357c924b7c99c075631d74">More...</a><br/></td></tr>
<tr class="separator:ga6ec69be58f357c924b7c99c075631d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga566677517a286527e05efc5680adbe6b"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga566677517a286527e05efc5680adbe6b">xkb_state::xkb_state_update_mask</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> depressed_mods, <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> latched_mods, <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> locked_mods, <a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> depressed_layout, <a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> latched_layout, <a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> locked_layout)</td></tr>
<tr class="memdesc:ga566677517a286527e05efc5680adbe6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a keyboard state from a set of explicit masks.  <a href="#ga566677517a286527e05efc5680adbe6b">More...</a><br/></td></tr>
<tr class="separator:ga566677517a286527e05efc5680adbe6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3111bf59537a9df6cea8c05c4ddab93e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga3111bf59537a9df6cea8c05c4ddab93e">xkb_state::xkb_state_serialize_mods</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> components)</td></tr>
<tr class="memdesc:ga3111bf59537a9df6cea8c05c4ddab93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The counterpart to xkb_state_update_mask for modifiers, to be used on the server side of serialization.  <a href="#ga3111bf59537a9df6cea8c05c4ddab93e">More...</a><br/></td></tr>
<tr class="separator:ga3111bf59537a9df6cea8c05c4ddab93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4b2d506dafd8aa68f41a3b81f7191fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gae4b2d506dafd8aa68f41a3b81f7191fb">xkb_state::xkb_state_serialize_layout</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> components)</td></tr>
<tr class="memdesc:gae4b2d506dafd8aa68f41a3b81f7191fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The counterpart to xkb_state_update_mask for layouts, to be used on the server side of serialization.  <a href="#gae4b2d506dafd8aa68f41a3b81f7191fb">More...</a><br/></td></tr>
<tr class="separator:gae4b2d506dafd8aa68f41a3b81f7191fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa5d800b0ae71ef78e412dc841d2e011"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gaaa5d800b0ae71ef78e412dc841d2e011">xkb_state::xkb_state_mod_name_is_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, const char *name, enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> type)</td></tr>
<tr class="memdesc:gaaa5d800b0ae71ef78e412dc841d2e011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a modifier is active in a given keyboard state by name.  <a href="#gaaa5d800b0ae71ef78e412dc841d2e011">More...</a><br/></td></tr>
<tr class="separator:gaaa5d800b0ae71ef78e412dc841d2e011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bfe54d8ff430a61077458b4ba926c68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga7bfe54d8ff430a61077458b4ba926c68">xkb_state::xkb_state_mod_names_are_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> type, enum <a class="el" href="group__state.html#gaf79b475eb908309ae1aa0e231b2c9aa8">xkb_state_match</a> match,...)</td></tr>
<tr class="memdesc:ga7bfe54d8ff430a61077458b4ba926c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a set of modifiers are active in a given keyboard state by name.  <a href="#ga7bfe54d8ff430a61077458b4ba926c68">More...</a><br/></td></tr>
<tr class="separator:ga7bfe54d8ff430a61077458b4ba926c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98b07d43090b761a79ac96967ae431c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga98b07d43090b761a79ac96967ae431c9">xkb_state::xkb_state_mod_index_is_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#a638bf7a52db06f383ce5a4ef99dfe539">xkb_mod_index_t</a> idx, enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> type)</td></tr>
<tr class="memdesc:ga98b07d43090b761a79ac96967ae431c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a modifier is active in a given keyboard state by index.  <a href="#ga98b07d43090b761a79ac96967ae431c9">More...</a><br/></td></tr>
<tr class="separator:ga98b07d43090b761a79ac96967ae431c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2101548a535fcee393b0ebadb341022"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gaa2101548a535fcee393b0ebadb341022">xkb_state::xkb_state_mod_indices_are_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> type, enum <a class="el" href="group__state.html#gaf79b475eb908309ae1aa0e231b2c9aa8">xkb_state_match</a> match,...)</td></tr>
<tr class="memdesc:gaa2101548a535fcee393b0ebadb341022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a set of modifiers are active in a given keyboard state by index.  <a href="#gaa2101548a535fcee393b0ebadb341022">More...</a><br/></td></tr>
<tr class="separator:gaa2101548a535fcee393b0ebadb341022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30061a16ebaccb7b34bb1ce7d106b001"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga30061a16ebaccb7b34bb1ce7d106b001">xkb_state::xkb_state_mod_index_is_consumed</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, <a class="el" href="xkbcommon_8h.html#a638bf7a52db06f383ce5a4ef99dfe539">xkb_mod_index_t</a> idx)</td></tr>
<tr class="memdesc:ga30061a16ebaccb7b34bb1ce7d106b001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a modifier is consumed by keyboard state translation for a key.  <a href="#ga30061a16ebaccb7b34bb1ce7d106b001">More...</a><br/></td></tr>
<tr class="separator:ga30061a16ebaccb7b34bb1ce7d106b001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcd5639842c473778012afc75cebc076"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gadcd5639842c473778012afc75cebc076">xkb_state::xkb_state_mod_mask_remove_consumed</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a> key, <a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> mask)</td></tr>
<tr class="memdesc:gadcd5639842c473778012afc75cebc076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove consumed modifiers from a modifier mask for a key.  <a href="#gadcd5639842c473778012afc75cebc076">More...</a><br/></td></tr>
<tr class="separator:gadcd5639842c473778012afc75cebc076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ffcb1f835d94cc39c5d8de16c5f2c37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga5ffcb1f835d94cc39c5d8de16c5f2c37">xkb_state::xkb_state_layout_name_is_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, const char *name, enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> type)</td></tr>
<tr class="memdesc:ga5ffcb1f835d94cc39c5d8de16c5f2c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a layout is active in a given keyboard state by name.  <a href="#ga5ffcb1f835d94cc39c5d8de16c5f2c37">More...</a><br/></td></tr>
<tr class="separator:ga5ffcb1f835d94cc39c5d8de16c5f2c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4011df1f305b9167249d8ba217328f6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#ga4011df1f305b9167249d8ba217328f6c">xkb_state::xkb_state_layout_index_is_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> idx, enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> type)</td></tr>
<tr class="memdesc:ga4011df1f305b9167249d8ba217328f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a layout is active in a given keyboard state by index.  <a href="#ga4011df1f305b9167249d8ba217328f6c">More...</a><br/></td></tr>
<tr class="separator:ga4011df1f305b9167249d8ba217328f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebde139a6b3f964f137bfeadc4793166"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gaebde139a6b3f964f137bfeadc4793166">xkb_state::xkb_state_led_name_is_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, const char *name)</td></tr>
<tr class="memdesc:gaebde139a6b3f964f137bfeadc4793166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a LED is active in a given keyboard state by name.  <a href="#gaebde139a6b3f964f137bfeadc4793166">More...</a><br/></td></tr>
<tr class="separator:gaebde139a6b3f964f137bfeadc4793166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5a02e6f26ccd29b95e32d6fcb8f8149"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__state.html#gaa5a02e6f26ccd29b95e32d6fcb8f8149">xkb_state::xkb_state_led_index_is_active</a> (struct <a class="el" href="structxkb__state.html">xkb_state</a> *state, <a class="el" href="xkbcommon_8h.html#af6e951bdbcba8fb7e2532a8ebc6c9c87">xkb_led_index_t</a> idx)</td></tr>
<tr class="memdesc:gaa5a02e6f26ccd29b95e32d6fcb8f8149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a LED is active in a given keyboard state by index.  <a href="#gaa5a02e6f26ccd29b95e32d6fcb8f8149">More...</a><br/></td></tr>
<tr class="separator:gaa5a02e6f26ccd29b95e32d6fcb8f8149"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Creating, destroying and manipulating keyboard state objects. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga631f03db07f30774659ab3f787b152e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__state.html#ga631f03db07f30774659ab3f787b152e7">xkb_key_direction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the direction of the key (press / release). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga631f03db07f30774659ab3f787b152e7aa685cb474cd090014d1049f74c3e3ec5"></a>XKB_KEY_UP</em>&nbsp;</td><td class="fielddoc">
<p>The key was released. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga631f03db07f30774659ab3f787b152e7a10b02b45f1fceae1b43bc69162f84678"></a>XKB_KEY_DOWN</em>&nbsp;</td><td class="fielddoc">
<p>The key was pressed. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga04e8eac0666cc64dee6f0d5a7a773a03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifier and layout types for state objects. </p>
<p>This enum is bitmaskable, e.g. (XKB_STATE_MODS_DEPRESSED | XKB_STATE_MODS_LATCHED) is valid to exclude locked modifiers.</p>
<p>In XKB, the DEPRESSED components are also known as 'base'. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga04e8eac0666cc64dee6f0d5a7a773a03a82fc290363aaa579fa4957c7a72b8ce6"></a>XKB_STATE_MODS_DEPRESSED</em>&nbsp;</td><td class="fielddoc">
<p>Depressed modifiers, i.e. </p>
<p>a key is physically holding them. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga04e8eac0666cc64dee6f0d5a7a773a03af95b6c2b4979c32588abe8a960351434"></a>XKB_STATE_MODS_LATCHED</em>&nbsp;</td><td class="fielddoc">
<p>Latched modifiers, i.e. </p>
<p>will be unset after the next non-modifier key press. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga04e8eac0666cc64dee6f0d5a7a773a03a95d6c496c78b6da162f7c78fbfc22bbc"></a>XKB_STATE_MODS_LOCKED</em>&nbsp;</td><td class="fielddoc">
<p>Locked modifiers, i.e. </p>
<p>will be unset after the key provoking the lock has been pressed again. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga04e8eac0666cc64dee6f0d5a7a773a03a2357b9f2490e89ab2d549695ea49de4f"></a>XKB_STATE_MODS_EFFECTIVE</em>&nbsp;</td><td class="fielddoc">
<p>Effective modifiers, i.e. </p>
<p>currently active and affect key processing (derived from the other state components). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga04e8eac0666cc64dee6f0d5a7a773a03ae2030e8ff7db5ee988920633e2b08e88"></a>XKB_STATE_LAYOUT_DEPRESSED</em>&nbsp;</td><td class="fielddoc">
<p>Depressed layout, i.e. </p>
<p>a key is physically holding it. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga04e8eac0666cc64dee6f0d5a7a773a03aaed45ef0bd8de351e096178c9b559345"></a>XKB_STATE_LAYOUT_LATCHED</em>&nbsp;</td><td class="fielddoc">
<p>Latched layout, i.e. </p>
<p>will be unset after the next non-modifier key press. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga04e8eac0666cc64dee6f0d5a7a773a03a8b3f6503e09ad7a43a3be092cc7cfaca"></a>XKB_STATE_LAYOUT_LOCKED</em>&nbsp;</td><td class="fielddoc">
<p>Locked layout, i.e. </p>
<p>will be unset after the key provoking the lock has been pressed again. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga04e8eac0666cc64dee6f0d5a7a773a03a751a3a712f1a25225e13114266b29726"></a>XKB_STATE_LAYOUT_EFFECTIVE</em>&nbsp;</td><td class="fielddoc">
<p>Effective layout, i.e. </p>
<p>currently active and affects key processing (derived from the other state components). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga04e8eac0666cc64dee6f0d5a7a773a03a9d22ee4abdad31a3e24afdede62c3c6d"></a>XKB_STATE_LEDS</em>&nbsp;</td><td class="fielddoc">
<p>LEDs (derived from the other state components). </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaf79b475eb908309ae1aa0e231b2c9aa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__state.html#gaf79b475eb908309ae1aa0e231b2c9aa8">xkb_state_match</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Match flags for xkb_state_mod_indices_are_active and xkb_state_mod_names_are_active, specifying how the conditions for a successful match. </p>
<p>XKB_STATE_MATCH_NON_EXCLUSIVE is bitmaskable with the other modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggaf79b475eb908309ae1aa0e231b2c9aa8acc8bf019ef4abad1eff3762ab67fd1cf"></a>XKB_STATE_MATCH_ANY</em>&nbsp;</td><td class="fielddoc">
<p>Returns true if any of the modifiers are active. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaf79b475eb908309ae1aa0e231b2c9aa8a22afd2884474ad692b580a8b91413b5f"></a>XKB_STATE_MATCH_ALL</em>&nbsp;</td><td class="fielddoc">
<p>Returns true if all of the modifiers are active. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaf79b475eb908309ae1aa0e231b2c9aa8a4ae1c11ddb747718871afb24adbfb0d6"></a>XKB_STATE_MATCH_NON_EXCLUSIVE</em>&nbsp;</td><td class="fielddoc">
<p>Makes matching non-exclusive, i.e. </p>
<p>will not return false if a modifier not specified in the arguments is active. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga281f0dc1cab624ab11e7c4d318d9d4ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structxkb__state.html">xkb_state</a> * xkb_state_new </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__keymap.html">xkb_keymap</a> *&#160;</td>
          <td class="paramname"><em>keymap</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new keyboard state object for a keymap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keymap</td><td>The keymap for which to create the state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new keyboard state object, or NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga331c9404262721da3f657eb9300c0eef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structxkb__state.html">xkb_state</a> * xkb_state_ref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a new reference on a keyboard state object. </p>
<dl class="section return"><dt>Returns</dt><dd>The passed in object. </dd></dl>

</div>
</div>
<a class="anchor" id="gacf5a9ee65857c4bdb7fbb5fbaa2dc115"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xkb_state_unref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a reference on a keybaord state object, and possibly free it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state. If it is NULL, this function does nothing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7cad922d12dcfe040db29db77c88b876"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structxkb__keymap.html">xkb_keymap</a> * xkb_state_get_keymap </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the keymap from which a keyboard state object was created. </p>
<dl class="section return"><dt>Returns</dt><dd>The keymap which was used in <a class="el" href="group__state.html#ga281f0dc1cab624ab11e7c4d318d9d4ac" title="Create a new keyboard state object for a keymap. ">xkb_state_new()</a> to create this state object.</dd></dl>
<p>This function does not take a new reference on the keymap; you must explicitly reference it yourself if you plan to use it beyond the lifetime of the state. </p>

</div>
</div>
<a class="anchor" id="gac554aa20743a621692c1a744a05e06ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> xkb_state_update_key </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#ga631f03db07f30774659ab3f787b152e7">xkb_key_direction</a>&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the keyboard state to reflect a given key being pressed or released. </p>
<dl class="section return"><dt>Returns</dt><dd>A mask of state components that have changed as a result of the update. If nothing in the state has changed, returns 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga47311e7268935dd2fe3e6ef057a82cb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_key_get_syms </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="xkbcommon_8h.html#a79e604a22703391bdfe212cfc10ea007">xkb_keysym_t</a> **&#160;</td>
          <td class="paramname"><em>syms_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the keysyms obtained from pressing a particular key in a given keyboard state. </p>
<p>Get the keysyms for a key according to the current active layout, modifiers and shift level for the key, as determined by a keyboard state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The keyboard state object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The keycode of the key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">syms_out</td><td>An immutable array of keysyms corresponding the key in the given keyboard state.</td></tr>
  </table>
  </dd>
</dl>
<p>As an extension to XKB, this function can return more than one keysym. If you do not want to handle this case, you can use <a class="el" href="group__state.html#gae56031a8c1d48e7802da32f5f39f5738" title="Get the single keysym obtained from pressing a particular key in a given keyboard state...">xkb_state_key_get_one_sym()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of keysyms in the syms_out array. If no keysyms are produced by the key in the given keyboard state, returns 0 and sets syms_out to NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="gae56031a8c1d48e7802da32f5f39f5738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xkbcommon_8h.html#a79e604a22703391bdfe212cfc10ea007">xkb_keysym_t</a> xkb_state_key_get_one_sym </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a>&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the single keysym obtained from pressing a particular key in a given keyboard state. </p>
<p>This function is similar to <a class="el" href="group__state.html#ga47311e7268935dd2fe3e6ef057a82cb0" title="Get the keysyms obtained from pressing a particular key in a given keyboard state. ">xkb_state_key_get_syms()</a>, but with a simplified interface for users which cannot or do not want to handle the case where multiple keysyms are returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The keysym. If the key does not have exactly one keysym, returns XKB_KEY_NoSymbol</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__state.html#ga47311e7268935dd2fe3e6ef057a82cb0" title="Get the keysyms obtained from pressing a particular key in a given keyboard state. ">xkb_state_key_get_syms()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac59ad6a608fb36055ecaf8d09449174f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> xkb_state_key_get_layout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a>&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the effective layout index for a key in a given keyboard state. </p>
<dl class="section return"><dt>Returns</dt><dd>The layout index for the key in the given keyboard state. If the given keycode is invalid, or if the key is not included in any layout at all, returns XKB_LAYOUT_INVALID.</dd></dl>
<dl class="section invariant"><dt>Invariant</dt><dd>If the returned layout is valid, the following always holds: <div class="fragment"><div class="line"><a class="code" href="group__state.html#gac59ad6a608fb36055ecaf8d09449174f" title="Get the effective layout index for a key in a given keyboard state. ">xkb_state_key_get_layout</a>(state, key) &lt; <a class="code" href="group__components.html#gad5d59aef2778a33387ffdaf8f992b689" title="Get the number of layouts for a specific key. ">xkb_keymap_num_layouts_for_key</a>(keymap, key)</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6ec69be58f357c924b7c99c075631d74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xkbcommon_8h.html#a7eb38bea2a311b6ff033816278d5bbea">xkb_level_index_t</a> xkb_state_key_get_level </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the effective shift level for a key in a given keyboard state and layout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The keyboard state. </td></tr>
    <tr><td class="paramname">key</td><td>The keycode of the key. </td></tr>
    <tr><td class="paramname">layout</td><td>The layout for which to get the shift level. This must be smaller than: <div class="fragment"><div class="line"><a class="code" href="group__components.html#gad5d59aef2778a33387ffdaf8f992b689" title="Get the number of layouts for a specific key. ">xkb_keymap_num_layouts_for_key</a>(keymap, key) </div>
</div><!-- fragment --> usually it would be: <div class="fragment"><div class="line"><a class="code" href="group__state.html#gac59ad6a608fb36055ecaf8d09449174f" title="Get the effective layout index for a key in a given keyboard state. ">xkb_state_key_get_layout</a>(state, key) </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shift level index. If the key or layout are invalid, returns XKB_LEVEL_INVALID.</dd></dl>
<dl class="section invariant"><dt>Invariant</dt><dd>If the returned level is valid, the following always holds: <div class="fragment"><div class="line"><a class="code" href="group__state.html#ga6ec69be58f357c924b7c99c075631d74" title="Get the effective shift level for a key in a given keyboard state and layout. ">xkb_state_key_get_level</a>(state, key, layout) &lt; <a class="code" href="group__components.html#gafc5aa736f1eb86a5377b98a03fb6d690" title="Get the number of shift levels for a specific key and layout. ">xkb_keymap_num_levels_for_key</a>(keymap, key, layout)</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga566677517a286527e05efc5680adbe6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a> xkb_state_update_mask </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a>&#160;</td>
          <td class="paramname"><em>depressed_mods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a>&#160;</td>
          <td class="paramname"><em>latched_mods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a>&#160;</td>
          <td class="paramname"><em>locked_mods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a>&#160;</td>
          <td class="paramname"><em>depressed_layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a>&#160;</td>
          <td class="paramname"><em>latched_layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a>&#160;</td>
          <td class="paramname"><em>locked_layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a keyboard state from a set of explicit masks. </p>
<p>This entry point is really only for window systems and the like, where a master process holds an <a class="el" href="structxkb__state.html" title="Opaque keyboard state object. ">xkb_state</a>, then serializes it over a wire protocol, and clients then use the serialization to feed in to their own <a class="el" href="structxkb__state.html" title="Opaque keyboard state object. ">xkb_state</a>.</p>
<p>All parameters must always be passed, or the resulting state may be incoherent.</p>
<p>The serialization is lossy and will not survive round trips; it must only be used to feed slave state objects, and must not be used to update the master state.</p>
<p>Please do not use this unless you fit the description above.</p>
<dl class="section return"><dt>Returns</dt><dd>A mask of state components that have changed as a result of the update. If nothing in the state has changed, returns 0.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03" title="Modifier and layout types for state objects. ">xkb_state_component</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3111bf59537a9df6cea8c05c4ddab93e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> xkb_state_serialize_mods </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td>
          <td class="paramname"><em>components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The counterpart to xkb_state_update_mask for modifiers, to be used on the server side of serialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The keyboard state. </td></tr>
    <tr><td class="paramname">components</td><td>A mask of the modifier state components to serialize. State components other than XKB_STATE_MODS_* are ignored. If XKB_STATE_MODS_EFFECTIVE is included, all other state components are ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A xkb_mod_mask_t representing the given components of the modifier state.</dd></dl>
<p>This function should not be used in regular clients; please use the xkb_state_mod_*_is_active API instead. </p>

</div>
</div>
<a class="anchor" id="gae4b2d506dafd8aa68f41a3b81f7191fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a> xkb_state_serialize_layout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td>
          <td class="paramname"><em>components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The counterpart to xkb_state_update_mask for layouts, to be used on the server side of serialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The keyboard state. </td></tr>
    <tr><td class="paramname">components</td><td>A mask of the layout state components to serialize. State components other than XKB_STATE_LAYOUT_* are ignored. If XKB_STATE_LAYOUT_EFFECTIVE is included, all other state components are ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A layout index representing the given components of the layout state.</dd></dl>
<p>This function should not be used in regular clients; please use the xkb_state_layout_*_is_active API instead. </p>

</div>
</div>
<a class="anchor" id="gaaa5d800b0ae71ef78e412dc841d2e011"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_mod_name_is_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a modifier is active in a given keyboard state by name. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the modifier is active, 0 if it is not. If the modifier name does not exist in the keymap, returns -1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7bfe54d8ff430a61077458b4ba926c68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_mod_names_are_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#gaf79b475eb908309ae1aa0e231b2c9aa8">xkb_state_match</a>&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a set of modifiers are active in a given keyboard state by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The keyboard state. </td></tr>
    <tr><td class="paramname">type</td><td>The component of the state against which to match the given modifiers. </td></tr>
    <tr><td class="paramname">match</td><td>The manner by which to match the state against the given modifiers. </td></tr>
    <tr><td class="paramname">...</td><td>The set of of modifier names to test, terminated by a NULL argument (sentinel).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the modifiers are active, 0 if they are not. If any of the modifier names do not exist in the keymap, returns -1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga98b07d43090b761a79ac96967ae431c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_mod_index_is_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a638bf7a52db06f383ce5a4ef99dfe539">xkb_mod_index_t</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a modifier is active in a given keyboard state by index. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the modifier is active, 0 if it is not. If the modifier index is invalid in the keymap, returns -1. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa2101548a535fcee393b0ebadb341022"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_mod_indices_are_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#gaf79b475eb908309ae1aa0e231b2c9aa8">xkb_state_match</a>&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a set of modifiers are active in a given keyboard state by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The keyboard state. </td></tr>
    <tr><td class="paramname">type</td><td>The component of the state against which to match the given modifiers. </td></tr>
    <tr><td class="paramname">match</td><td>The manner by which to match the state against the given modifiers. </td></tr>
    <tr><td class="paramname">...</td><td>The set of of modifier indexes to test, terminated by a XKB_MOD_INVALID argument (sentinel).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the modifiers are active, 0 if they are not. If any of the modifier indexes are invalid in the keymap, returns -1. </dd></dl>

</div>
</div>
<a class="anchor" id="ga30061a16ebaccb7b34bb1ce7d106b001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_mod_index_is_consumed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a638bf7a52db06f383ce5a4ef99dfe539">xkb_mod_index_t</a>&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a modifier is consumed by keyboard state translation for a key. </p>
<p>Some functions, like <a class="el" href="group__state.html#ga47311e7268935dd2fe3e6ef057a82cb0" title="Get the keysyms obtained from pressing a particular key in a given keyboard state. ">xkb_state_key_get_syms()</a>, look at the state of the modifiers in the keymap and derive from it the correct shift level to use for the key. For example, in a US layout, pressing the key labeled &lt;A&gt; while the Shift modifier is active, generates the keysym 'A'. In this case, the Shift modifier is said to be consumed. However, the Num Lock modifier does not affect this translation at all, even if it active, so it is not consumed by this translation.</p>
<p>It may be desirable for some application to not reuse consumed modifiers for further processing, e.g. for hotkeys or keyboard shortcuts. To understand why, consider some requirements from a standard shortcut mechanism, and how they are implemented:</p>
<ol type="1">
<li>The shortcut's modifiers must match exactly to the state. For example, it is possible to bind separate actions to &lt;Alt&gt;&lt;Tab&gt; and to &lt;Alt&gt;&lt;Shift&gt;&lt;Tab&gt;. Further, if only &lt;Alt&gt;&lt;Tab&gt; is bound to an action, pressing &lt;Alt&gt;&lt;Shift&gt;&lt;Tab&gt; should not trigger the shortcut. Effectively, this means that the modifiers are compared using the equality operator (==).</li>
<li>Only relevant modifiers are considered for the matching. For example, Caps Lock and Num Lock should not generally affect the matching, e.g. when matching &lt;Alt&gt;&lt;Tab&gt; against the state, it does not matter whether Num Lock is active or not. These relevant, or significant, modifiers usually include Alt, Control, Shift, Super and similar. Effectively, this means that non-significant modifiers are masked out, before doing the comparison as described above.</li>
<li>The matching must be independent of the layout/keymap. For example, the &lt;Plus&gt; (+) symbol is found on the first level on some layouts, and requires holding Shift on others. If you simply bind the action to the &lt;Plus&gt; keysym, it would work for the unshifted kind, but not for the others, because the match against Shift would fail. If you bind the action to &lt;Shift&gt;&lt;Plus&gt;, only the shifted kind would work. So what is needed is to recognize that Shift is used up in the translation of the keysym itself, and therefore should not be included in the matching. Effectively, this means that consumed modifiers (Shift in this example) are masked out as well, before doing the comparison.</li>
</ol>
<p>To summarize, this is how the matching would be performed: </p>
<div class="fragment"><div class="line">(keysym == shortcut_keysym) &amp;&amp;</div>
<div class="line">((state_modifiers &amp; ~consumed_modifiers &amp; significant_modifiers) == shortcut_modifiers)</div>
</div><!-- fragment --><p><code>state_modifiers</code> are the modifiers reported by <a class="el" href="group__state.html#ga98b07d43090b761a79ac96967ae431c9" title="Test whether a modifier is active in a given keyboard state by index. ">xkb_state_mod_index_is_active()</a> and similar functions. <code>consumed_modifiers</code> are the modifiers reported by <a class="el" href="group__state.html#ga30061a16ebaccb7b34bb1ce7d106b001" title="Test whether a modifier is consumed by keyboard state translation for a key. ">xkb_state_mod_index_is_consumed()</a>. <code>significant_modifiers</code> are decided upon by the application/toolkit/user; it is up to them to decide whether these are configurable or hard-coded.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the modifier is consumed, 0 if it is not. If the modifier index is not valid in the keymap, returns -1.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__state.html#gadcd5639842c473778012afc75cebc076" title="Remove consumed modifiers from a modifier mask for a key. ">xkb_state_mod_mask_remove_consumed()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadcd5639842c473778012afc75cebc076"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a> xkb_state_mod_mask_remove_consumed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997">xkb_keycode_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#a41b3ee62ae73ec041b68165bf97869e8">xkb_mod_mask_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove consumed modifiers from a modifier mask for a key. </p>
<p>Takes the given modifier mask, and removes all modifiers which are consumed for that particular key (as in <a class="el" href="group__state.html#ga30061a16ebaccb7b34bb1ce7d106b001" title="Test whether a modifier is consumed by keyboard state translation for a key. ">xkb_state_mod_index_is_consumed()</a>).</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__state.html#ga30061a16ebaccb7b34bb1ce7d106b001" title="Test whether a modifier is consumed by keyboard state translation for a key. ">xkb_state_mod_index_is_consumed()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5ffcb1f835d94cc39c5d8de16c5f2c37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_layout_name_is_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a layout is active in a given keyboard state by name. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the layout is active, 0 if it is not. If no layout with this name exists in the keymap, return -1.</dd></dl>
<p>If multiple layouts in the keymap have this name, the one with the lowest index is tested.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39" title="Index of a keyboard layout. ">xkb_layout_index_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4011df1f305b9167249d8ba217328f6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_layout_index_is_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39">xkb_layout_index_t</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__state.html#ga04e8eac0666cc64dee6f0d5a7a773a03">xkb_state_component</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a layout is active in a given keyboard state by index. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the layout is active, 0 if it is not. If the layout index is not valid in the keymap, returns -1.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="xkbcommon_8h.html#ad37512642806c55955e1cd5a30efcc39" title="Index of a keyboard layout. ">xkb_layout_index_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaebde139a6b3f964f137bfeadc4793166"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_led_name_is_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a LED is active in a given keyboard state by name. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the LED is active, 0 if it not. If no LED with this name exists in the keymap, returns -1.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="xkbcommon_8h.html#af6e951bdbcba8fb7e2532a8ebc6c9c87" title="Index of a keyboard LED. ">xkb_led_index_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5a02e6f26ccd29b95e32d6fcb8f8149"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xkb_state_led_index_is_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structxkb__state.html">xkb_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xkbcommon_8h.html#af6e951bdbcba8fb7e2532a8ebc6c9c87">xkb_led_index_t</a>&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a LED is active in a given keyboard state by index. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the LED is active, 0 if it not. If the LED index is not valid in the keymap, returns -1.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="xkbcommon_8h.html#af6e951bdbcba8fb7e2532a8ebc6c9c87" title="Index of a keyboard LED. ">xkb_led_index_t</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jun 12 2013 09:46:13 for libxkbcommon by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.4 </li>
  </ul>
</div>
</body>
</html>
